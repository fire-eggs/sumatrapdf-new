
// DON'T EDIT MANUALLY !!!!
// auto-generated by scripts/gen_settings.py !!!!

#include "BaseUtil.h"
#include "Settings.h"

struct StructPointerInfo;

#define POINTER_SIZE 8

typedef struct {
    int                  size;
    int                  pointersCount;
    StructPointerInfo *  pointersInfo;
} StructDef;

// information about a single field
struct StructPointerInfo {
    // from the beginning of the struct
    int offset;
    // what kind of structure it points to, needed
    // for recursive application of the algorithm
    // NULL if that structure doesn't need fixup
    // (has no pointers)
    StructDef *def;
};

STATIC_ASSERT(sizeof(ForwardSearchSettings) == 16, ForwardSearchSettings_is_16_bytes);
StructDef gForwardSearchSettingsStructDef = { 16, 0, NULL};

STATIC_ASSERT(sizeof(PaddingSettings) == 12, PaddingSettings_is_12_bytes);
StructDef gPaddingSettingsStructDef = { 12, 0, NULL};

STATIC_ASSERT(offsetof(AdvancedSettings, pagePadding) == 12, pagePadding_is_12_bytes_in_AdvancedSettings);
STATIC_ASSERT(offsetof(AdvancedSettings, forwardSearch) == 20, forwardSearch_is_20_bytes_in_AdvancedSettings);
StructPointerInfo gAdvancedSettingsPointers[] = {
    { 12, &gPaddingSettingsStructDef },
    { 20, &gForwardSearchSettingsStructDef },
};

STATIC_ASSERT(sizeof(AdvancedSettings) == 28, AdvancedSettings_is_28_bytes);
StructDef gAdvancedSettingsStructDef = { 28, 2, &gAdvancedSettingsPointers[0]};

static void unserialize_struct_r(char *data, StructDef *def, char *base)
{
    for (int i=0; i < def->pointersCount; i++) {
        int off = def->pointersInfo[i].offset;
        StructDef *memberDef = def->pointersInfo[i].def;
        char *pval = base + off;
        Ptr<char> *ptrToPtr = (Ptr<char>*)(data + off);
        ptrToPtr->ptr = pval;
        if (memberDef)
            unserialize_struct_r(pval, memberDef, base);
    }
}

// a serialized format is a linear chunk of memory with pointers
// replaced with offsets from the beginning of the memory.
// to unserialize, we need to fix them up i.e. convert offsets
// to pointers
// TODO: add bool makeCopy option that will make deep copy of data
// (using malloc()), so that it can be easily modified before being
// serialized for storage. We'll also need free_struct(char *data, StructDef *def)
// for freeing this copy
char* unserialize_struct(char *data, StructDef *def)
{
    unserialize_struct_r(data, def, data);
    return data;
}
